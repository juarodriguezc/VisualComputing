<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Visual Computing</title><link>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/</link><description>Recent content on Visual Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/coloring/</guid><description>Shaders # Coloring # sketch.js let colorShader; let cmy; let v1, v2, v3; let uMaterial1, uMaterial2; // Color picker let colorPickerL, colorPickerR; const colorL = &amp;#34;#CC804D&amp;#34;; const colorR = &amp;#34;#E61A66&amp;#34;; function preload() { // The vertex shader defines how vertices are projected onto clip space. // Most of the times a projection and modelview matrix are needed for it: // https://visualcomputing.github.io/docs/shaders/programming_paradigm/ // Here, however, we are going to: // 1.</description></item><item><title/><link>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/image_processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/image_processing/</guid><description>Shaders # Image processing # sketch.js let maskShader; let img; let video_src; let video_on; let mask; let path = &amp;#39;/VisualComputing/sketches/workshop3/ImageProcessing&amp;#39; function preload() { video_src = createVideo([path+&amp;#39;/img/video.mp4&amp;#39;]); video_src.hide(); // by default video shows up in separate dom maskShader = readShader(path+&amp;#39;/mask.frag&amp;#39;, { varyings: Tree.texcoords2 }); //img = loadImage(&amp;#39;/sketches/shaders/tree.jpeg&amp;#39;); //img = loadImage(&amp;#39;./img/lupin.png&amp;#39;); img = loadImage(path+&amp;#39;/img/cuy.webp&amp;#39;); //img = loadImage(&amp;#39;/sketches/shaders/acacias.jpeg&amp;#39;); //img = loadImage(&amp;#39;/sketches/shaders/honda.jpg&amp;#39;); //img = loadImage(&amp;#39;/sketches/shaders/v.jpg&amp;#39;); //img = loadImage(&amp;#39;/sketches/shaders/v.jpeg&amp;#39;); //img = loadImage(&amp;#39;/sketches/shaders/pictographs.jpg&amp;#39;); //img = loadImage(&amp;#39;/sketches/shaders/honda.</description></item><item><title/><link>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/non_euclidian_geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/non_euclidian_geometry/</guid><description>Shaders # Non Euclidian Geometry # Ejemplo del profesor # sketch.js let easycam; let edge = 80; let scooter; let scooterTex; let amogus; let amogusTex; let texShader; let path = &amp;#39;/VisualComputing/sketches/workshop3/nonEuclidian1&amp;#39; function preload() { // no varyings need to be emitted from the vertex shader texShader = readShader(path+&amp;#39;/shader.frag&amp;#39;, { varyings: Tree.NONE }); amogus = loadModel(path+&amp;#39;/models/amogus.obj&amp;#39;, true); scooter = loadModel(path+&amp;#39;/models/scooter.obj&amp;#39;, true); } function setup() { createCanvas(400, 400, WEBGL); // no need to normalize the texture // textureMode(NORMAL); shader(texShader); // resolution will be used to sample the offscreen textures emitResolution(texShader); easycam = createEasyCam(); scooterTex = createGraphics(width, height, WEBGL); amogusTex = createGraphics(width, height, WEBGL); } function draw() { // 1.</description></item><item><title/><link>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/procedural_texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://juarodriguezc.github.io/VisualComputing/docs/workshops/shaders/procedural_texturing/</guid><description>Shaders # Procedural Texturing # sketch.js let pg; let truchetShader; let img; let lastMouse = 0; path = &amp;#39;/VisualComputing/sketches/workshop3/ProceduralTexturing&amp;#39; function preload() { // shader adapted from here: https://thebookofshaders.com/09/ truchetShader = readShader(path+&amp;#39;/truchet.frag&amp;#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); img = loadImage(path+&amp;#39;/img/scotish.jpg&amp;#39;); } function setup() { createCanvas(400, 400, WEBGL); // create frame buffer object to render the procedural texture pg = createGraphics(400, 400, WEBGL); textureMode(NORMAL); noStroke(); pg.noStroke(); pg.textureMode(NORMAL); // use truchetShader to render onto pg pg.</description></item></channel></rss>